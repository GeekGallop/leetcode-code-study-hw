## 01
有一个特殊的5键键盘，上面有a，ctrl-c，ctrl-x，ctrl-v，ctrl-a五个键。

- a键在屏幕上输出一个字母a；

- ctrl-c将当前选择的字母复制到剪贴板；

- ctrl-x将当前选择的字母复制到剪贴板，并清空选择的字母；

- ctrl-v将当前剪贴板里的字母输出到屏幕；

- ctrl-a选择当前屏幕上的所有字母。

##### 注意：

- 剪贴板初始为空，新的内容被复制到剪贴板时会覆盖原来的内容
- 当屏幕上没有字母时，ctrl-a无效
- 当没有选择字母时，ctrl-c和ctrl-x无效
- 当有字母被选择时，a和ctrl-v这两个有输出功能的键会先清空- 选择的字母，再进行输出
- 给定一系列键盘输入，输出最终屏幕上字母的数量。

##### 输入描述
输入为一行，为简化解析，用数字1 2 3 4 5代表a，ctrl-c，ctrl-x，ctrl-v，ctrl-a五个键的输入，数字用空格分隔。
##### 输出描述
输出一个数字，为最终屏幕上字母的数量。
##### 用例
|输入|输出|说明
|---------|-------|-------
|1 1 1|3|连续键入3个a，故屏幕上字母的长度为3。
|1 1 5 1 5 2 4 4 |2|输入两个a后ctrl-a选择这两个a，再输入a时选择的两个a先被清空，所以此时屏幕只有一个a，


---

## 02
##### 题目描述：
数轴×有两个点的序列 A={A1， A2, …, Am}和 B={B1, B2, ..., Bn}， Ai 和 Bj 均为正整数， A、 B 已经从小到大排好序， A、 B 均肯定不为空，

给定一个距离 R（正整数），列出同时满足如下条件的所有（Ai， Bj）数对

##### 条件
1. Ai <= Bj
2. Ai,Bj 距离小于等于 R，但如果 Ai 找不到 R 范围内的 Bj，则列出距它最近的 1 个 Bj，当然此种情况仍然要满足 1，但如果仍然找不到，就丢弃 Ai

##### 原型
车路协同场景，一条路上发生了有很多事件（ A），要通过很多路测设备（ B）广播给路上的车，需要给每个事件找到一个合适的路测设备去发送广播消息。

##### 输入描述
按照人易读的格式输入一行数据，参见输入样例，其中" ABR={， }"中的每个字符都是关键分割符，输入中无空格，其他均为任意正整数，

输入 A 和 B 已经排好序， A 和 B 的大小不超过 50，正整数范围不会超过 65535。

##### 输出描述
（ Ai,Bj）数对序列，排列顺序满足序列中前面的 Ax<=后面的 Ay，前面的 Bx<=后面的 By，

因为输入 A 和 B 已经排好序，所以实际上输出结果不用特意排序，排序不是考察点。

##### 用例
|输入|输出|说明
|---------|-------|-------
|A={1,3,5},B={2,4,6},R=1|(1,2)(3,4)(5,6)|无

---
## 03
##### 题目描述
给定一个字符串，里边可能包含"()"、"[]"、"{}"三种括号，请编写程序检查该字符串中的括号是否成对出现，且嵌套关系正确。
若括号成对出现且嵌套关系正确，或该字符串中无括号字符，输出：true；
若未正确使用括号字符，输出：false。
实现时，无需考虑非法输入。

##### 输入描述
无
##### 输出描述
无

##### 用例
|输入|输出|说明
|---------|-------|-------
|(1+2)/(0.5+1)|true|无

---
## 04
##### 题目描述
(1+(2+3)*(3+(8+0))+1-2)这是一个简单的数学表达式,今天不是计算它的值,而是比较它的括号匹配是否正确。

前面这个式子可以简化为(()(()))这样的括号我们认为它是匹配正确的,

而((())这样的我们就说他是错误的。注意括号里面的表达式可能是错的,也可能有多个空格，对于这些我们是不用去管的，

我们只关心括号是否使用正确。

##### 输入描述
给出一行表达式(长度不超过 100)。

##### 输出描述
如果匹配正确输出括号的对数，否则输出-1

##### 用例
|输入|输出|说明
|---------|-------|-------
|(1+(2+3)*(3+(8+0))+1-2)|      4 |无

---
## 05 验证回文串
##### 题目
如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。

字母和数字都属于字母数字字符。

给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。

 

##### 示例 1：

输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。
示例 2：

输入：s = "race a car"
输出：false
解释："raceacar" 不是回文串。
示例 3：

输入：s = " "
输出：true
解释：在移除非字母数字字符之后，s 是一个空字符串 "" 。
由于空字符串正着反着读都一样，所以是回文串。
 

##### 提示：

1 <= s.length <= 2 * 105
s 仅由可打印的 ASCII 字符组成

---
## 06 CPU算力分配
##### 题目描述
现有两组服务器A和B，每组有多个算力不同的CPU，其中 A[i] 是 A 组第 i 个CPU的运算能力，B[i] 是 B组 第 i 个CPU的运算能力。

一组服务器的总算力是各CPU的算力之和。

为了让两组服务器的算力相等，允许从每组各选出一个CPU进行一次交换，

求两组服务器中，用于交换的CPU的算力，并且要求从A组服务器中选出的CPU，算力尽可能小。

##### 输入描述
第一行输入为L1和L2，以空格分隔，L1表示A组服务器中的CPU数量，L2表示B组服务器中的CPU数量。

第二行输入为A组服务器中各个CPU的算力值，以空格分隔。

第三行输入为B组服务器中各个CPU的算力值，以空格分隔。

- 1 ≤ L1 ≤ 10000
- 1 ≤ L2 ≤ 10000
- 1 ≤ A[i] ≤ 100000
- 1 ≤ B[i] ≤ 100000

##### 输出描述
对于每组测试数据，输出两个整数，以空格分隔，依次表示A组选出的CPU算力，B组选出的CPU算力。要求从A组选出的CPU的算力尽可能小。

##### 用例
|输入|输出|说明
|---------|-------|-------
|2 2<br>1 1<br>2 2|1 2|从A组中选出算力为1的CPU，与B组中算力为2的进行交换，使两组服务器的算力都等于3。
|2 2<br>1 2<br>2 3|1 2|无

---
## 07 We Are A Team
##### 题目描述
总共有 n 个人在机房，每个人有一个标号（1<=标号<=n），他们分成了多个团队，需要你根据收到的 m 条消息判定指定的两个人是否在一个团队中，具体的：

1. 消息构成为 a b c，整数 a、b 分别代表两个人的标号，整数 c 代表指令
2. c == 0 代表 a 和 b 在一个团队内
3. c == 1 代表需要判定 a 和 b 的关系，如果 a 和 b 是一个团队，输出一行'we are a team',如果不是，输出一行'we are not a team'
4. c 为其他值，或当前行 a 或 b 超出 1~n 的范围，输出'da pian zi'

##### 输入描述
1. 第一行包含两个整数 n，m(1<=n,m<100000),分别表示有 n 个人和 m 条消息
2. 随后的 m 行，每行一条消息，消息格式为：a b c(1<=a,b<=n,0<=c<=1)

##### 输出描述
1. c ==1,根据 a 和 b 是否在一个团队中输出一行字符串，在一个团队中输出'we are a team',不在一个团队中输出'we are not a team'
2. c 为其他值，或当前行 a 或 b 的标号小于 1 或者大于 n 时，输出字符串'da pian zi'
3. 如果第一行 n 和 m 的值超出约定的范围时，输出字符串"NULL"。

##### 用例
|输入|输出|说明
|---------|-------|-------
|5 7<br>1 2 0<br>4 5 0<br>2 3 0<br>1 2 1<br>2 3 1<br>4 5 1<br>1 5 1|we are a team<br>we are a team<br>we are a team<br>we are not a team|无

---
## 08 两数之和绝对值最小
##### 题目描述
给定一个从小到大的有序整数序列（存在正整数和负整数）数组 nums ，请你在该数组中找出两个数，其和的绝对值(|nums[x]+nums[y]|)为最小值，并返回这个绝对值。

每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

##### 输入描述
一个通过空格分割的有序整数序列字符串，最多1000个整数，且整数数值范围是 -65535~65535。

##### 输出描述
两数之和绝对值最小值

##### 用例
|输入|输出|说明
|---------|-------|-------
|-3 -1 5 7 11 15|2|因为 \|nums[0] + nums[2]\| = \|-3 + 5\| = 2 最小，所以返回 2。

---
## 09 字符串压缩解压
##### 题目描述
有一种简易压缩算法：针对全部由小写英文字母组成的字符串，将其中连续超过两个相同字母的部分压缩为连续个数加该字母，其他部分保持原样不变。

例如：字符串"aaabbccccd"经过压缩成为字符串"3abb4cd"。

请您编写解压函数，根据输入的字符串，判断其是否为合法压缩过的字符串，

若输入合法则输出解压缩后的字符串，否则输出字符串"!error"来报告错误。

##### 输入描述
输入一行，为一个ASCII字符串，长度不会超过100字符，用例保证输出的字符串长度也不会超过100字符。

##### 输出描述
若判断输入为合法的经过压缩后的字符串，则输出压缩前的字符串；

若输入不合法，则输出字符串"!error"。

##### 用例
|输入|输出|说明
|---------|-------|-------
|4dff|ddddff|4d扩展为dddd，故解压后的字符串为ddddff。
|2dff|!error|两个d不需要压缩，故输入不合法。
|4d@A|!error|全部由小写英文字母组成的字符串压缩后不会出现特殊字符@和大写字母A，故输入不合法。
---
## 10 API集群负载统计
##### 题目描述
某个产品的RESTful API集合部署在服务器集群的多个节点上，近期对客户端访问日志进行了采集，需要统计各个API的访问频次，根据热点信息在服务器节点之间做负载均衡，现在需要实现热点信息统计查询功能。

RESTful API是由多个层级构成，层级之间使用 / 连接，如 /A/B/C/D 这个地址，A属于第一级，B属于第二级，C属于第三级，D属于第四级。

现在负载均衡模块需要知道给定层级上某个名字出现的频次，未出现过用0表示，实现这个功能。

##### 输入描述
第一行为N，表示访问历史日志的条数，0 ＜ N ≤ 100。
接下来N行，每一行为一个RESTful API的URL地址，约束地址中仅包含英文字母和连接符 / ，最大层级为10，每层级字符串最大长度为10。
最后一行为层级L和要查询的关键字。

##### 输出描述
输出给定层级上，关键字出现的频次，使用完全匹配方式（大小写敏感）。

##### 用例
|输入|输出|说明
|---------|-------|-------
|5<br> /huawei/computing/no/one<br> /huawei/computing<br> /huawei<br> /huawei/cloud/no/one<br> /huawei/wireless/no/one<br> 2 computing|2|在第二层级上，computing出现了2次，因此输出2
|5<br> /huawei/computing/no/one<br> /huawei/computing<br> /huawei<br> /huawei/cloud/no/one<br> /huawei/wireless/no/one<br> 4 two|0|存在第四层级的URL上，没有出现two，因此频次是0

---
## 11 会议室占用时间
##### 题目描述
现有若干个会议，所有会议共享一个会议室，用数组表示各个会议的开始时间和结束时间，格式为：

[[会议1开始时间, 会议1结束时间], [会议2开始时间, 会议2结束时间]]

请计算会议室占用时间段。

##### 输入描述
第一行输入一个整数 n，表示会议数量
之后输入n行，每行两个整数，以空格分隔，分别表示会议开始时间，会议结束时间

##### 输出描述
输出多行，每个两个整数，以空格分隔，分别表示会议室占用时间段开始和结束

##### 用例
|输入|输出|说明
|---------|-------|-------
|4<br> 1 4<br> 2 5<br> 7 9<br> 14 18|1 5<br> 7 9<br> 14 18|<br>输入：[[1,4],[2,5],[7,9],[14,18]]<br> <br>输出：[[1,5],[7,9],[14,18]]<br> <br>说明：时间段[1,4]和[2,5]重叠，合并为[1,5]<br>
|2<br> 1 4<br> 4 5|1 5|<br>输入：[[1,4],[4,5]]<br> <br>输出：[[1,5]]<br> <br>说明：时间段[1,4]和[4,5]连续<br>

---
## 12 停车场车辆统计
##### 题目描述
特定大小的停车场，数组cars[]表示，其中1表示有车，0表示没车。

车辆大小不一，小车占一个车位（长度1），货车占两个车位（长度2），卡车占三个车位（长度3）。

统计停车场最少可以停多少辆车，返回具体的数目。

##### 输入描述
整型字符串数组cars[]，其中1表示有车，0表示没车，数组长度小于1000。

##### 输出描述
整型数字字符串，表示最少停车数目。

##### 用例
|输入|输出|说明
|---------|-------|-------
|1,0,1|2|<br>1个小车占第1个车位<br> <br>第二个车位空<br> <br>1个小车占第3个车位<br> <br>最少有两辆车<br>
|1,1,0,0,1,1,1,0,1|3|<br>1个货车占第1、2个车位<br> <br>第3、4个车位空<br> <br>1个卡车占第5、6、7个车位<br> <br>第8个车位空<br> <br>1个小车占第9个车位<br> <br>最少3辆车<br>

---
## 13 免单统计
##### 题目描述
华为商城举办了一个促销活动，如果某顾客是某一秒内最早时刻下单的顾客（可能是多个人），则可以获取免单。

请你编程计算有多少顾客可以获取免单。

##### 输入描述
输入为 n 行数据，每一行表示一位顾客的下单时间
以（年-月-日时-分-秒.毫秒） yyyy-MM-ddHH:mm:ss.fff 形式给出。
所有输入保证合法。

##### 输出描述
输出一个整数，表示有多少顾客可以获取免单。

##### 用例
|输入|输出|说明
|---------|-------|-------
|3<br> 2019-01-01 00:00:00.001<br> 2019-01-01 00:00:00.002<br> 2019-01-01 00:00:00.003|1|样例 1 中，三个订单都是同一秒内下单，只有第一个订单最早下单，可以免单。
|3<br> 2019-01-01 08:59:00.123<br> 2019-01-01 08:59:00.123<br> 2018-12-28 10:08:00.999|3|样例 2 中，前两个订单是同一秒内同一时刻（也是最早）下单，都可免单，第三个订单是当前秒内唯一一个订单（也是最早），也可免单。
|5<br> 2019-01-01 00:00:00.004<br> 2019-01-01 00:00:00.004<br> 2019-01-01 00:00:01.006<br> 2019-01-01 00:00:01.006<br> 2019-01-01 00:00:01.005|3|样例 3 中，前两个订单是同一秒内同一时刻（也是最早）下单，第三第四个订单不是当前秒内最早下单，不可免单，第五个订单可以免单。

---
## 14 全排列
##### 题目描述
给定一个只包含大写英文字母的字符串S，要求你给出对S重新排列的所有不相同的排列数。

如：S为ABA，则不同的排列有ABA、AAB、BAA三种。

##### 输入描述
输入一个长度不超过10的字符串S，我们确保都是大写的。

##### 输出描述
输出S重新排列的
所有不相同的排列数
（包含自己本身）。

##### 用例
|输入|输出|说明
|---------|-------|-------
|ABA|3|无
|ABCDEFGHHA|907200|无

---
## 15 内存冷热标记
##### 题目描述
现代计算机系统中通常存在多级的存储设备，针对海量 workload 的优化的一种思路是将热点内存页优先放到快速存储层级，这就需要对内存页进行冷热标记。

一种典型的方案是基于内存页的访问频次进行标记，如果统计窗口内访问次数大于等于设定阈值，则认为是热内存页，否则是冷内存页。

对于统计窗口内跟踪到的访存序列和阈值，现在需要实现基于频次的冷热标记。内存页使用页框号作为标识。

##### 输入描述
第一行输入为 N，表示访存序列的记录条数，0 < N ≤ 10000。
第二行为访存序列，空格分隔的 N 个内存页框号，页面号范围 0 ~ 65535，同一个页框号可能重复出现，出现的次数即为对应框号的频次。
第三行为热内存的频次阈值 T，正整数范围 1 ≤ T ≤ 10000。

##### 输出描述
第一行输出标记为热内存的内存页个数，如果没有被标记的热内存页，则输出 0 。
如果第一行 > 0，则接下来按照访问频次降序输出内存页框号，一行一个，频次一样的页框号，页框号小的排前面。

##### 用例
|输入|输出|说明
|---------|-------|-------
|10<br> 1 2 1 2 1 2 1 2 1 2<br> 5|2<br> 1<br> 2|内存页1和内存页2均被访问了5次，达到了阈值5，因此热内存页有2个。内存页1和内存页2的访问频次相等，页框号小的排前面。
|5<br> 1 2 3 4 5<br> 3|0|访存跟踪里面访存频次没有超过3的，因此热内存个数为0。

---
## 16 冠亚军排名，奖牌榜排名
##### 题目描述
2012伦敦奥运会即将到来，大家都非常关注奖牌榜的情况，现在我们假设奖牌榜的排名规则如下:

我们假设国家名称不超过二十个字符，各类奖牌数不超过100，且大于0.

##### 输入描述
第一行输入一个整数N（0<N<21），代表国家数量，
然后接下来的N行，每行包含：
一个字符串Name表示各个国家的名称和三个整数Gi,Si,Bi表示每个获得的gold medal,silver medal,bronze medal的数量，以空格隔开，如(China 51 20 21),
具体见样例输入。
5
 China 32 28 34
 England 12 34 22
 France 23 33 2
 Japan 12 34 25
 Rusia 23 43 0

##### 输出描述
输出奖牌榜的依次顺序，只输出国家名称，各占一行，具体见样例输出。
China
 Rusia
 France
 Japan
 England

##### 用例
|输入|输出|说明
|---------|-------|-------
|5<br> China 32 28 34<br> England 12 34 22<br> France 23 33 2<br> Japan 12 34 25<br> Rusia 23 43 0|China<br> Rusia<br> France<br> Japan<br> England|无

---
## 17 分割均衡字符串
##### 题目描述
均衡串定义：字符串中只包含两种字符，且这两种字符的个数相同。

给定一个均衡字符串，请给出可分割成新的均衡子串的最大个数。

约定：字符串中只包含大写的 X 和 Y 两种字符。

##### 输入描述
输入一个均衡串。

##### 输出描述
输出可分割成新的均衡子串的最大个数。

##### 用例
|输入|输出|说明
|---------|-------|-------
|XXYYXY|2|XXYYXY可分割为2个均衡子串，分别为：XXYY、XY

---
## 18 分披萨
##### 题目描述
"吃货"和"馋嘴"两人到披萨店点了一份铁盘（圆形）披萨，并嘱咐店员将披萨按放射状切成大小相同的偶数个小块。但是粗心的服务员将披萨切成了每块大小都完全不同奇数块，且肉眼能分辨出大小。

由于两人都想吃到最多的披萨，他们商量了一个他们认为公平的分法：从"吃货"开始，轮流取披萨。除了第一块披萨可以任意选取外，其他都必须从缺口开始选。

他俩选披萨的思路不同。"馋嘴"每次都会选最大块的披萨，而且"吃货"知道"馋嘴"的想法。

已知披萨小块的数量以及每块的大小，求"吃货"能分得的最大的披萨大小的总和。

##### 输入描述
第 1 行为一个正整数奇数 N，表示披萨小块数量。
接下来的第 2 行到第 N + 1 行（共 N 行），每行为一个正整数，表示第 i 块披萨的大小
披萨小块从某一块开始，按照一个方向次序顺序编号为 1 ~ N

##### 输出描述
"吃货"能分得到的最大的披萨大小的总和。

##### 用例
|输入|输出|说明
|---------|-------|-------
|5<br> 8<br> 2<br> 10<br> 5<br> 7|19|<br>此例子中，有 5 块披萨。每块大小依次为 8、2、10、5、7。<br> <br>按照如下顺序拿披萨，可以使"吃货"拿到最多披萨：<br> <br>"吃货" 拿大小为 10 的披萨<br> <br>"馋嘴" 拿大小为 5 的披萨<br> <br>"吃货" 拿大小为 7 的披萨<br> <br>"馋嘴" 拿大小为 8 的披萨<br> <br>"吃货" 拿大小为 2 的披萨<br> <br>至此，披萨瓜分完毕，"吃货"拿到的披萨总大小为 10 + 7 + 2 = 19<br> <br>可能存在多种拿法，以上只是其中一种。<br>

---
## 19 分配土地
##### 题目描述
从前有个村庄，村民们喜欢在各种田地上插上小旗子，旗子上标识了各种不同的数字。

某天集体村民决定将覆盖相同数字的最小矩阵形的土地分配给村里做出巨大贡献的村民，请问此次分配土地，做出贡献的村民种最大会分配多大面积?

##### 输入描述
第一行输入 m 和 n，
第二行开始输入地图上的具体标识

##### 输出描述
此次分配土地，做出贡献的村民种最大会分配多大面积

##### 用例
|输入|输出|说明
|---------|-------|-------
|3 3<br> 1 0 1<br> 0 0 0<br> 0 1 0|9|土地上的旗子为1，其坐标分别为(0,0)，(2,1)以及(0,2)，为了覆盖所有旗子，矩阵需要覆盖的横坐标为0和2，纵坐标为0和2，所以面积为9，即（2-0+1）*（2-0+1）= 9
|3 3<br> 1 0 2<br> 0 0 0<br> 0 3 4|1|由于不存在成对的小旗子，故而返回1，即一块土地的面积。

---
## 20 判断字符串子序列
##### 题目描述
给定字符串 target和 source，判断 target是否为 source 的子序列。

你可以认为target和 source 中仅包含英文小写字母。

字符串 source 可能会很长（长度~=500,000），而 target是个短字符串（长度<=100)。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。

（例如，”abc”是”aebycd”的一个子序列，而”ayb”不是）。

请找出最后一个子序列的起始位置。

##### 输入描述
第一行为target，短字符串（长度 <=100）
 第二行为source，长字符串（长度 ~= 500,000）

##### 输出描述
最后一个子序列的起始位置，即最后一个子序列首字母的下标

##### 用例
|输入|输出|说明
|---------|-------|-------
|abc<br> abcaybec|3|这里有两个abc的子序列满足，取下标较大的，故返回3。

---
## 21 剩余银饰的重量
##### 题目描述
有 N 块二手市场收集的银饰，每块银饰的重量都是正整数，收集到的银饰会被熔化用于打造新的饰品。

每一回合，从中选出三块最重的银饰，然后一起熔掉。

假设银饰的重量分别为 x 、y和z，且 x ≤ y ≤ z。那么熔掉的可能结果如下：

最后，

##### 输入描述
输入数据为两行：

##### 输出描述
如果剩余两块，返回较大的重量（若两块重量相同，返回任意一块皆可）；
如果只剩下一块，返回该块的重量；
如果没有剩下，就返回 0。

##### 用例
|输入|输出|说明
|---------|-------|-------
|3<br> 1 1 1|0|选出1 1 1，得到 0，最终数组转换为 []，最后没有剩下银块，返回0
|3<br> 3 7 10|1|选出 3 7 10，需要计算 (7-3) 和 (10-7) 的差值，即(7-3)-(10-7)=1，所以数组转换为 [1]，剩余一块，返回该块重量，返回1

---
## 22 勾股数元组
##### 题目描述
如果3个正整数(a,b,c)满足a^2 + b^2 = c^2的关系，则称(a,b,c)为勾股数（著名的勾三股四弦五），

为了探索勾股数的规律，我们定义如果勾股数(a,b,c)之间两两互质（即a与b，a与c，b与c之间均互质，没有公约数），则其为勾股数元组（例如(3,4,5)是勾股数元组，(6,8,10)则不是勾股数元组）。

请求出给定范围[N,M]内，所有的勾股数元组。

##### 输入描述
起始范围N，1 <= N <= 10000
结束范围M，N < M <= 10000

##### 输出描述
1. a,b,c请保证a < b < c,输出格式：a b c；
2. 多组勾股数元组请按照a升序，b升序，最后c升序的方式排序输出；
3. 给定范围中如果找不到勾股数元组时，输出”NA“。

##### 用例
|输入|输出|说明
|---------|-------|-------
|<br>1<br> <br>20<br>|3 4 5<br> 5 12 13<br> 8 15 17|<br>[1,20]范围内勾股数有：(3 4 5)，(5 12 13)，(6 8 10)，(8 15 17)，(9 12 15)，(12 16 20)；<br> <br>其中，满足(a,b,c)之间两两互质的勾股数元组有：(3 4 5)，(5 12 13)，(8 15 17);<br> <br>按输出描述中顺序要求输出结果。<br>
|<br>5<br> <br>10<br>|NA|<br>[5,10]范围内勾股数有：(6 8 10)；<br> <br>其中，没有满足(a,b,c)之间两两互质的勾股数元组；<br> <br>给定范围中找不到勾股数元组，输出”NA“<br>

---
## 23 单词加密
##### 题目描述
1、输入一个英文句子，句子中包含若干个单词，每个单词间有一个空格；

2、需要将句子中的每个单词按照要求加密输出。

要求：

1）单词中包括元音字符（‘aeuio’、‘AEUIO’，大小写都算），则将元音字符替换成‘*’

2）单词中不包括元音字符，将单词首尾字符进行对换

##### 输入描述
输入只有一行，包含一个长度都不超过100的字符串，表示英文句子。

##### 输出描述
输出只有一行，即按要求输出加密处理后的英文句子

##### 用例
|输入|输出|说明
|---------|-------|-------
|Hello world|H*ll* w*rld|无

---
## 24 单词接龙
##### 题目描述
单词接龙的规则是：

##### 输入描述
备注：

##### 用例
|输入|输出|说明
|---------|-------|-------
|0<br> 6<br> word<br> dd<br> da<br> dc<br> dword<br> d|worddwordda|先确定起始单词word，再接以d开头的且长度最长的单词dword，剩余以d开头且长度最长的有dd、da、dc，则取字典序最小的da，所以最后输出worddwordda。
|4<br> 6<br> word<br> dd<br> da<br> dc<br> dword<br> d|dwordda|先确定起始单词dword，剩余以d开头且长度最长的有dd、da、dc，则取字典序最小的da，所以最后输出dwordda。

---
## 25 单词重量
##### 题目描述
每个句子由多个单词组成，句子中的每个单词的长度都可能不一样，我们假设每个单词的长度Ni为该单词的重量，你需要做的就是给出整个句子的平均重量V。

##### 输入描述
无

##### 输出描述
无

##### 用例
|输入|输出|说明
|---------|-------|-------
|Who Love Solo|3.67|无

---
## 26 围棋的气
##### 题目描述
围棋棋盘由纵横各19条线垂直相交组成，棋盘上一共19 x 19 = 361 个交点，对弈双方一方执白棋，一方执黑棋，落子时只能将棋子置于交点上。

“气”是围棋中很重要的一个概念，某个棋子有几口气，是指其上下左右方向四个相邻的交叉点中，有几个交叉点没有棋子，由此可知：

现在，请根据输入的黑棋和白棋得到坐标位置，计算黑棋和白棋一共各有多少气？

##### 输入描述
输入包含两行数据，如：
0 5 8 9 9 10
 5 0 9 9 9 8

##### 输出描述
8 7
两个数字以空格分隔，第一个数代表黑棋的气数，第二个数代表白棋的气数。

##### 用例
|输入|输出|说明
|---------|-------|-------
|0 5 8 9 9 10<br> 5 0 9 9 9 8|8 7|<br>如果将输入数据放到棋盘上<br> <br><br><br> <br>数数黑棋一共8口气，数数白棋一共7口气。<br>

---
## 27 在字符串中找出连续最长的数字串(含“+-”号)
##### 题目描述
请在一个字符串中找出连续最长的数字串，并返回这个数字串。

如果存在长度相同的连续数字串，返回最后一个。

如果没有符合条件的字符串，返回空字符串””。

注意：

##### 输入描述
无

##### 输出描述
无

##### 用例
|输入|输出|说明
|---------|-------|-------
|1234567890abcd9.+12345.678.9ed|+12345.678|无

---
## 28 堆内存申请
##### 题目描述
有一个总空间为100字节的堆，现要从中新申请一块内存，内存分配原则为：优先紧接着前一块已使用内存，分配空间足够且最接近申请大小的空闲内存。

##### 输入描述
第1行是1个整数，表示期望申请的内存字节数
第2到第N行是用空格分割的两个整数，表示当前已分配的内存的情况，每一行表示一块已分配的连续内存空间，每行的第1和第2个整数分别表示偏移地址和内存块大小，如：
0 1
 3 2
表示 0 偏移地址开始的 1 个字节和 3 偏移地址开始的 2 个字节已被分配，其余内存空闲。

##### 输出描述
若申请成功，输出申请到内存的偏移；
若申请失败，输出 -1。

##### 用例
|输入|输出|说明
|---------|-------|-------
|1<br> 0 1<br> 3 2|1|堆中已使用的两块内存是偏移从0开始的1字节和偏移从3开始的2字节，空闲的两块内存是偏移从1开始2个字节和偏移从5开始95字节，根据分配原则，新申请的内存应从1开始分配1个字节，所以输出偏移为1。

---
## 29 堆栈中的剩余数字
##### 题目描述
向一个空栈中依次存入正整数，假设入栈元素 n(1<=n<=2^31-1)按顺序依次为 nx…n4、 n3、n2、 n1, 每当元素入栈时，如果 n1=n2+…+ny(y 的范围[2,x]， 1<=x<=1000)，则 n1~ny 全部元素出栈，重新入栈新元素 m(m=2*n1)。

如：依次向栈存入 6、 1、 2、 3, 当存入 6、 1、 2 时，栈底至栈顶依次为[6、 1、 2]；当存入 3时， 3=2+1， 3、 2、 1 全部出栈，重新入栈元素 6(6=2*3)，此时栈中有元素 6；

因为 6=6，所以两个 6 全部出栈，存入 12，最终栈中只剩一个元素 12。

##### 输入描述
使用单个空格隔开的正整数的字符串，如”5 6 7 8″， 左边的数字先入栈，输入的正整数个数为 x， 1<=x<=1000。

##### 输出描述
最终栈中存留的元素值，元素值使用空格隔开，如”8 7 6 5″， 栈顶数字在左边。 6 1 2 3

##### 用例
|输入|输出|说明
|---------|-------|-------
|5 10 20 50 85 1|1 170|5+10+20+50=85， 输入 85 时， 5、 10、 20、 50、 85 全部出栈，入栈 170，最终依次出栈的数字为 1 和 170。
|6 7 8 13 9|9 13 8 7 6|无
|1 2 5 7 9 1 2 2|4 1 9 14 1|无

---
## 30 多段线数据压缩
##### 题目描述
下图中，每个方块代表一个像素，每个像素用其行号和列号表示。

为简化处理，多线段的走向只能是水平、竖直、斜向45度。

上图中的多线段可以用下面的坐标串表示：(2,8),(3,7),(3,6),(3,5),(4,4),(5,3),(6,2),(7,3),(8,4),(7,5)。

但可以发现，这种表示不是最简的，其实只需要存储6个蓝色的关键点即可，它们是线段的起点、拐点、终点，而剩下4个点是冗余的。

现在，请根据输入的包含有冗余数据的多线段坐标列表，输出其最简化的结果。

##### 输入描述
2 8 3 7 3 6 3 5 4 4 5 3 6 2 7 3 8 4 7 5

##### 输出描述
2 8 3 7 3 5 6 2 8 4 7 5
压缩后的最简化坐标列表，和输入数据的格式相同。

##### 用例
|输入|输出|说明
|---------|-------|-------
|2 8 3 7 3 6 3 5 4 4 5 3 6 2 7 3 8 4 7 5|2 8 3 7 3 5 6 2 8 4 7 5|<br>如上图所示，6个蓝色像素的坐标依次是：<br> <br>(2, 8)、(3, 7)、(3, 5)、(6, 2)、(8, 4)、(7, 5)<br> <br>将他们按顺序输出即可。<br>

---
## 31 字符串分割(二)
##### 题目描述
给定一个非空字符串S，其被N个‘-’分隔成N+1的子串，给定正整数K，要求除第一个子串外，其余的子串每K个字符组成新的子串，并用‘-’分隔。
 对于新组成的每一个子串，如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母；
 反之，如果它含有的大写字母比小写字母多，则将这个子串的所有小写字母转换为大写字母；大小写字母的数量相等时，不做转换。

##### 输入描述
输入为两行，第一行为参数K，第二行为字符串S。

##### 输出描述
输出转换后的字符串。

##### 用例
|输入|输出|说明
|---------|-------|-------
|3<br> 12abc-abCABc-4aB@|12abc-abc-ABC-4aB-@|<br>子串为12abc、abCABc、4aB@，第一个子串保留，<br> <br>后面的子串每3个字符一组为abC、ABc、4aB、@，<br> <br>abC中小写字母较多，转换为abc，<br> <br>ABc中大写字母较多，转换为ABC，<br> <br>4aB中大小写字母都为1个，不做转换，<br> <br>@中没有字母，连起来即12abc-abc-ABC-4aB-@<br>
|12<br> 12abc-abCABc-4aB@|12abc-abCABc4aB@|<br>子串为12abc、abCABc、4aB@，第一个子串保留，<br> <br>后面的子串每12个字符一组为abCABc4aB@，<br> <br>这个子串中大小写字母都为4个，不做转换，<br> <br>连起来即12abc-abCABc4aB@<br>

---
## 32 字符串变换最小字符串
##### 题目描述
给定一个字符串s，最多只能进行一次变换，返回变换后能得到的最小字符串（按照字典序进行比较）。

变换规则：交换字符串中任意两个不同位置的字符。

##### 输入描述
一串小写字母组成的字符串s

##### 输出描述
按照要求进行变换得到的最小字符串。

##### 用例
|输入|输出|说明
|---------|-------|-------
|abcdef|abcdef|abcdef已经是最小字符串，不需要交换。
|bcdefa|acdefb|a和b进行位置交换，可以得到最小字符串

---
## 33 字符串序列判定
##### 题目描述
输入两个字符串 S 和 L ，都只包含英文小写字母。S长度 ≤ 100，L长度 ≤ 500,000。判定S是否是L的有效子串。

判定规则：S 中的每个字符在 L 中都能找到（可以不连续），且 S 在Ｌ中字符的前后顺序与 S 中顺序要保持一致。（例如，S = ”ace” 是 L= ”abcde” 的一个子序列且有效字符是a、c、e，而”aec”不是有效子序列，且有效字符只有a、e）

##### 输入描述
输入两个字符串 S 和 L，都只包含英文小写字母。S长度 ≤ 100，L长度 ≤ 500,000。
先输入S，再输入L，每个字符串占一行。

##### 输出描述
S 串最后一个有效字符在 L 中的位置。（首位从0开始计算，无有效字符返回-1）

##### 用例
|输入|输出|说明
|---------|-------|-------
|<br>ace<br> abcde<br>|4|无
|<br>fgh<br> abcde<br>|-1|无

---
## 34 字符串排序
##### 题目描述
排序规则：

##### 输入描述
无

##### 输出描述
无

##### 用例
|输入|输出|说明
|---------|-------|-------
|Hello hello world|Hello world|无
|i LOVE Cc I love CC Hello Hel Hellow|Cc Hel Hello Hellow i LOVE|无

---
## 35 字符串筛选排序
##### 题目描述
输入一个由N个大小写字母组成的字符串

按照ASCII码值从小到大进行排序

查找字符串中第K个最小ASCII码值的字母(k>=1)

输出该字母所在字符串中的位置索引(字符串的第一个位置索引为0)

k如果大于字符串长度则输出最大ASCII码值的字母所在字符串的位置索引

如果有重复字母则输出字母的最小位置索引

##### 输入描述
第一行输入一个由大小写字母组成的字符串
第二行输入k ，k必须大于0 ，k可以大于输入字符串的长度

##### 输出描述
输出字符串中第k个最小ASCII码值的字母所在字符串的位置索引
k如果大于字符串长度则输出最大ASCII码值的字母所在字符串的位置索引
如果第k个最小ASCII码值的字母存在重复 则输出该字母的最小位置索引

##### 用例
|输入|输出|说明
|---------|-------|-------
|AbCdeFG<br> 3|5|<br>根据ASCII码值排序，第三个ASCII码值的字母为F<br> <br>F在字符串中位置索引为5(0为字符串的第一个字母位置索引)<br>
|fAdDAkBbBq<br> 4|6|<br>根据ASCII码值排序前4个字母为AABB由于B重复则只取B的第一个最小位置索引6<br> <br>而不是第二个B的位置索引8<br>

---
## 36 字符统计及重排
##### 题目描述
给出一个仅包含字母的字符串，不包含空格，统计字符串中各个字母（区分大小写）出现的次数，

并按照字母出现次数从大到小的顺序。输出各个字母及其出现次数。

如果次数相同，按照自然顺序进行排序，且小写字母在大写字母之前。

##### 输入描述
输入一行，为一个仅包含字母的字符串。

##### 输出描述
按照字母出现次数从大到小的顺序输出各个字母和字母次数，用英文分号分隔，注意末尾的分号；
字母和次数间用英文冒号分隔。

##### 用例
|输入|输出|说明
|---------|-------|-------
|xyxyXX|x:2;y:2;X:2;|每个字符出现的个数都是2，故x排在y之前，而小写字母x在X之前
|abababb|b:4;a:3;|b的出现个数比a多，故b排在a之前

---
## 37 密码解密
##### 题目描述
给定一段“密文”字符串 s，其中字符都是经过“密码本”映射的，现需要将“密文”解密并输出。

映射的规则（'a' ~ 'i'）分别用（'1' ~ '9'）表示；（'j' ~ 'z'）分别用（"10*" ~ "26*"）表示。

约束：映射始终唯一。

##### 输入描述
“密文”字符串

##### 输出描述
明文字符串

##### 用例
|输入|输出|说明
|---------|-------|-------
|20*19*20*|tst|无

---
## 38 密码输入检测
##### 题目描述
给定用户密码输入流 input，输入流中字符 '<' 表示退格，可以清除前一个输入的字符，请你编写程序，输出最终得到的密码字符，并判断密码是否满足如下的密码安全要求。

密码安全要求如下：

注意空串退格后仍然为空串，且用户输入的字符串不包含 '<' 字符和空白字符。

##### 输入描述
用一行字符串表示输入的用户数据，输入的字符串中 '<' 字符标识退格，用户输入的字符串不包含空白字符，例如：
ABC<c89%000<

##### 输出描述
输出经过程序处理后，输出的实际密码字符串，并输出改密码字符串是否满足密码安全要求。两者间由 ',' 分隔， 例如：
ABc89%00,true

##### 用例
|输入|输出|说明
|---------|-------|-------
|ABC<c89%000<|ABc89%00,true|多余的C和0由于退格被去除,最终用户输入的密码为ABc89%00，且满足密码安全要求，输出true

---
## 39 密钥格式化
##### 题目描述
给定一个非空字符串 S，其被 N 个’-‘分隔成 N+1 的子串，给定正整数 K，要求除第一个子串外，其余的串每 K 个用’-‘分隔，并将小写字母转换为大写。

##### 输入描述
正整数 K 和‘-’分割的字符串，如：
2
 25G3C-abc-d

##### 输出描述
转换后的字符串

##### 用例
|输入|输出|说明
|---------|-------|-------
|<br>4<br> 5F3Z-2e-9-w<br>|5F3Z-2E9W|<br>字符串 S 被分成了两个部分，每部分 4 个字符；<br> <br>注意，两个额外的破折号需要删掉。<br>
|<br>2<br> 2-5g-3-J<br>|2-5G-3J|字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。


<!------------
## 0
##### 题目描述


##### 输入描述

##### 输出描述


##### 用例
|输入|输出|说明
|---------|-------|-------
|         |       |
------------>
